{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":""},{"location":"#_1","title":"Getting started","text":"<p>CoBaIR is a python library for Context Based Intention Recognition.  It provides the means to infer an intention from given context.  An intention is a binary value e.g. <code>repair pipe</code> that can either be present or not. Only one intention can be present at a time. Context on the otherhand can have multiple discrete instantiations e.g. <code>weather:sunny|cloudy|raining</code>. If context values are continuous, discretizer functions can be used to create discrete values. From the inferred intention in a HRI scenario the robot can perform corresponding actions to help the human with a specific task.</p>"},{"location":"#publications","title":"Publications","text":"<p>For a more in-depth explanation consult the following papers:</p> <ul> <li>Concept Paper</li> <li>Full Paper for IEEE RO-MAN Conference</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install CoBaIR\n</code></pre> <p>You can install the library from your local copy after cloning this repo with pip using <code>pip install .</code>  or install the newest experimental features from the <code>develop</code> branch with <code>pip install git+https://github.com/dfki-ric/CoBaIR.git@develop</code></p>"},{"location":"#known-issues","title":"Known Issues","text":"<p>On some Linux Distros there seems to be a problem with a shared library. This Solutions suggests to <code>export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libstdc++.so.6</code> which works on Ubuntu 22.04.</p>"},{"location":"#graphical-user-interface","title":"Graphical User Interface","text":"<p>To make the configuration of a scenario easier we provide a Graphical User Interface(GUI). The GUI can be started with</p> <pre><code>python start_configurator.py\n</code></pre> <p>if you want to start the GUI with a loaded config use</p> <pre><code>python start_configurator.py -f config.yml\n</code></pre>"},{"location":"#tutorial","title":"Tutorial","text":"<p>For a step-by-step guide on how to use CoBaIR, check out our Tutorial.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>The Documentation can be accessed on https://dfki-ric.github.io/CoBaIR/</p>"},{"location":"#bayesian-approach","title":"Bayesian Approach","text":"<p>In the bayesian approach CoBaIR uses a two-layer Bayesian Net of the following structure. </p>"},{"location":"#config-format","title":"Config Format","text":"<p>Configs will be saved in yml files. For convenience the is a configurator which can be started with</p> <pre><code>python start_configurator.py\n</code></pre>"},{"location":"#bayesian-approach_1","title":"Bayesian Approach","text":"<p>The configuration file for a two layer bayesian net for context based intention recognition follows the given format:</p> <pre><code># List of contexts. Contexts can have different discrete instantiations. \n# Number of instantiations must be larger than 1.\n# For all discrete instantiations a prior probability must be given(sum for one context must be 1)\ncontexts:\n  context 1:\n    instantiation 1 : float\n      .\n    instantiation m_1 : float\n  context n:\n    instantiation 1 : float\n      .\n    instantiation m_n : float\n# List of intentions. Intentions are always binary(either present or not)\n# For every intention the context variables and their influence on the intention is given\n# [very high, high, medium, low, very low, no] =&gt; [5, 4, 3, 2, 1, 0]\nintentions: \n  intention 1:\n    context 1:\n        instantiation 1: int # one out of [5, 4, 3, 2, 1, 0]\n        .\n        instantiation m_1: int # one out of [5, 4, 3, 2, 1, 0]\n    context n:\n        instantiation 1: int # one out of [5, 4, 3, 2, 1, 0]\n        .\n        instantiation m_n: int # one out of [5, 4, 3, 2, 1, 0]\n  intention p:\n    context 1:\n        instantiation 1: int # one out of [5, 4, 3, 2, 1, 0]\n        .\n        instantiation m_1: int # one out of [5, 4, 3, 2, 1, 0]\n    context n:\n        instantiation 1: int # one out of [5, 4, 3, 2, 1, 0]\n        .\n        instantiation m_n: int # one out of [5, 4, 3, 2, 1, 0]\n# decision_threshold is a float value between 0 and 1 which decides \n# when an intention should be considered in inference.\n# Probability must be greater than decision_threshold.\ndecision_threshold: float\n\n</code></pre>"},{"location":"#how-to-contribute","title":"How to contribute","text":"<p>If you find any Bugs or want to contribute/suggest a new feature you can create a Merge Request / Pull Request or contact me directly via adrian.lubitz@dfki.de</p>"},{"location":"#run-tests","title":"Run tests","text":"<p>Tests are implemented with pytest. To install test dependencies you need to run </p> <pre><code>pip install -r requirements/test_requirements.txt\n</code></pre> <p>Then you can run </p> <pre><code>python -m pytest tests/\n</code></pre> <p>You can as well see the test report for a specific commit in gitlab under pipeline-&gt;Tests</p>"},{"location":"#coverage","title":"Coverage","text":"<p>If you want to see coverage for the tests you can run</p> <pre><code>coverage run -m pytest tests/\n</code></pre> <p>Use </p> <pre><code>coverage report\n</code></pre> <p>or </p> <pre><code>coverage html\n</code></pre> <p>You can as well see the coverage for a specific job in gitlab under jobs</p> <p>To show results of the coverage analysis.</p>"},{"location":"#build-docu","title":"Build docu","text":"<p>Documentation is implemented with the material theme for mkdocs.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Install all dependencies for building the docu with </p> <pre><code>pip install -r requirements/doc_requirements.txt\n</code></pre>"},{"location":"#build","title":"Build","text":"<p>Build the docu with </p> <pre><code>mkdocs build\n</code></pre> <p>The documentation will be in the <code>site</code> folder.</p>"},{"location":"#authors","title":"Authors","text":"<p>Adrian Lubitz &amp; Arunima Gopikrishnan</p>"},{"location":"#funding","title":"Funding","text":"<p>CoBaIR is currently developed in the Robotics Group of the University of Bremen, together with the Robotics Innovation Center of the German Research Center for Artificial Intelligence (DFKI) in Bremen. CoBaIR has been funded by the German Federal Ministry for Economic Affairs and Energy and the German Aerospace Center (DLR). CoBaIR been used and/or developed in the KiMMI-SF project.</p> <p> </p>"},{"location":"API/","title":"CoBaIR","text":"<p>This module provides a class for a two-layer bayes net for context based intention recognition.</p>"},{"location":"API/#CoBaIR.bayes_net.BayesNet","title":"<code> BayesNet        </code>","text":"Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>class BayesNet():\n    def __init__(self, config: dict = None, bn_verbosity: int = 0, validate: bool = True) -&gt; None:\n        '''\n        Initializes the BayesNet with the given config.\n\n        Args:\n            config: A dict with a config following the config format.\n            bn_verbosity: sets the verbose flag for bnlearn. See [bnlearn API](\n                https://erdogant.github.io/bnlearn/pages/html/bnlearn.bnlearn.html?highlight=verbose\n                #bnlearn.bnlearn.make_DAG) for more information\n            validate: Flag if the given config should be validated or not. \n                This is necessary to load invalid configs\n        '''\n        self.log = logging.getLogger(self.__class__.__name__)\n\n        self.valid = False\n        self.bn_verbosity = bn_verbosity\n        self.discretization_functions = {}\n\n        if config is None:\n            validate = False\n        config = config_to_default_dict(config)\n\n        # if not config:\n        #     self.config = {'intentions': defaultdict(lambda: defaultdict(\n        #         lambda: defaultdict(int))), 'contexts': defaultdict(lambda: defaultdict(float))}\n        #     return\n\n        self.config = deepcopy(config)\n        self.decision_threshold = self.config['decision_threshold']\n\n        if validate:\n            self.validate_config()\n\n        # Translation dicts for context to card number in bnlearn and vice versa\n        self._create_value_to_card()\n        self._create_card_to_value()\n        # Translation dict for the std values to probabilities\n        self.value_to_prob = {5: 0.95, 4: 0.75,\n                              3: 0.5, 2: 0.25, 1: 0.05, 0: 0.0}\n\n        # initialize the bayes net structure\n        self.contexts = self.evidence = list(self.config['contexts'].keys())\n        self.intentions = list(self.config['intentions'].keys())\n        self.edges = list(itertools.product(self.contexts, self.intentions))\n        self._create_evidence_card()\n\n        # create CPTs for the bayes net\n        self.cpts = []\n        self._create_context_cpts()\n        self._create_intention_cpts()\n        if self.valid:\n            self.DAG = bn.make_DAG(self.edges, CPD=self.cpts,\n                                   verbose=self.bn_verbosity)\n\n    def _create_value_to_card(self):\n        '''\n        Initializes the translation dict for the context values to card numbers for bnlearn\n        '''\n        self.value_to_card = defaultdict(dict)\n        for context, probabilities in self.config['contexts'].items():\n            count = 0\n            for key, _ in probabilities.items():\n                self.value_to_card[context][key] = count\n                count += 1\n\n    def _create_card_to_value(self):\n        '''\n        Initializes the backtranslation dict for the context values to card numbers for bnlearn\n        '''\n        self.card_to_value = defaultdict(dict)\n        for context, values in self.value_to_card.items():\n            for name, num in values.items():\n                self.card_to_value[context][num] = name\n\n    def _create_context_cpts(self):\n        '''\n        Create the Conditional Probability Tables for all context nodes in the DAG and \n            APPENDS them to self.cpts\n        '''\n        for context, probabilities in self.config['contexts'].items():\n            values = [None] * len(probabilities)\n            for value in probabilities:\n                values[self.value_to_card[context][value]] = [\n                    probabilities[value]]\n            self.cpts.append(TabularCPD(variable=context,\n                             variable_card=len(probabilities), values=values))\n\n    def _create_intention_cpts(self):\n        '''\n        Create the Conditional Probability Tables for all intention nodes in the DAG and \n            APPENDS them to self.cpts\n        '''\n        for intention, context_influence in self.config['intentions'].items():\n            values = self._calculate_probability_values(context_influence)\n            # create a TabularCPD\n            self.cpts.append(\n                TabularCPD(variable=intention,\n                           variable_card=2,  # intentions are always binary\n                           values=values,\n                           evidence=self.evidence,\n                           evidence_card=self.evidence_card)\n            )\n\n    def _create_evidence_card(self):\n        '''\n        create the evidence_card for bnlearn\n        '''\n        self.evidence_card = []\n        for evidence_variable in self.evidence:\n            self.evidence_card.append(\n                len(self.config['contexts'][evidence_variable]))\n\n    def _create_combined_context(self, context_influence: dict) -&gt; dict:\n        \"\"\"\n        Creates a dict with the combined contexts in card index format from context_influence.\n        TODO: example makes no sense - replace\n        Args:\n            context_influence:\n                A dict with the influence values for contexts.\n                Example: {'speech commands':\n                            {'pickup': 5, 'handover': 0, 'other': 0},\n                          'human holding object':\n                            {True: 1, False: 4},\n                          'human activity':\n                            {'idle': 4, 'working': 3}\n                          }\n\n        Returns:\n            dict: A dict with the combined contexts\n            Example: {(0, 2): {('pickup', 'working'): 5}), (0, 1): {('pickup', True): 5})}\n\n        \"\"\"\n        combined_context = {}\n        for context in context_influence:\n            if isinstance(context, tuple):\n                combined_context[tuple(map(self.evidence.index, context))\n                                 ] = context_influence[context]\n        return combined_context\n\n    def _alter_combined_context(self, count: Counter, context_influence: dict,\n                                combined_context: dict) -&gt; dict:\n        \"\"\"\n        Overwrites the influence values for the cases of combined influence.\n\n        Args:\n            count: \n                A counter that indicates for which combination of context the average is calculated\n            context_influence: \n                A dict with the influence values for contexts.\n                Example: {'speech commands':\n                            {'pickup': 5, 'handover': 0, 'other': 0},\n                          'human holding object':\n                            {True: 1, False: 4},\n                          'human activity':\n                            {'idle': 4, 'working': 3}\n                          }\n            combined_context:\n                A dict with the combined contexts\n                Example: {(0, 2): {('pickup', 'working'): 5}), (0, 1): {('pickup', True): 5})}\n\n        Returns:\n            dict:\n                A dict with the adjusted influence values for contexts.\n                Example: {'speech commands':\n                            {'pickup': 5, 'handover': 0, 'other': 0},\n                          'human holding object':\n                            {True: 5, False: 4},\n                          'human activity':\n                            {'idle': 4, 'working': 3}\n                          }\n\n        \"\"\"\n        active_case = list(\n            map(lambda tup: self.card_to_value[self.evidence[tup[0]]][tup[1]], enumerate(count)))\n\n        altered_context_influence = deepcopy(context_influence)\n\n        for context_tuple, values in combined_context.items():\n            combined_case = True\n            # There should always be only one key\n            value_tuple = list(values.keys())[0]\n            for i, context_index in enumerate(context_tuple):\n                if active_case[context_index] != value_tuple[i]:\n                    combined_case = False\n                    break\n            if combined_case:\n                for i, index in enumerate(context_tuple):\n                    altered_context_influence[self.evidence[index]][value_tuple[i]] = \\\n                        combined_context[context_tuple][value_tuple]\n                break\n        return altered_context_influence\n\n    def _calculate_probability_values(self, context_influence: dict) -&gt; list:\n        '''\n        Calculates the probability values with the given context_influence from the config.\n\n        Influence on the positive case(intention is true) is calculated as the\n        average over all influences for the given context.\n        The influence mapping is given in\n        self.value_to_prob = {5: 0.95, 4: 0.75,\n            3: 0.5, 2: 0.25, 1: 0.05, 0: 0.0}\n        Args:\n            context_influence:\n                A dict with the influence values for contexts.\n                Example: {'speech commands':\n                            {'pickup': 5, 'handover': 0, 'other': 0},\n                        'human holding object':\n                            {True: 1, False: 4},\n                        'human activity':\n                            {'idle': 4, 'working': 3}\n                        }\n        Returns:\n            list:\n            A list of lists containing the probability values for the negative and positive.\n            Example:\n\n            [[0.416, 0.5, 0.183, 0.266, 0.733, 0.816, 0.5, 0.583, 0.733, 0.816, 0.5, 0.583],\n\n            [0.583, 0.5, 0.816, 0.733, 0.266, 0.183, 0.5, 0.416, 0.266, 0.183, 0.5, 0.416]]\n        '''\n        # For every intention calculate the average of their influencing contexts\n        pos_values = []\n        combined_context = self._create_combined_context(context_influence)\n\n        for count in Counter(self.evidence_card):\n            # Here I need to average over all the values that are in the config at position count\n            average = 0\n\n            # alternate context_influence\n            altered_context_influence = self._alter_combined_context(\n                count, context_influence, combined_context)\n\n            ####\n\n            for i in range(len(self.evidence_card)):\n                value = self.card_to_value[self.evidence[i]][count[i]]\n                influence = altered_context_influence[self.evidence[i]][value]\n                prob = self.value_to_prob.get(influence, 0)\n                average += prob\n            if len(self.evidence) &gt; 0:\n                average /= len(self.evidence)\n            else:\n                average = 0\n            pos_values.append(average)\n        # create neg_values\n        neg_values = [1-value for value in pos_values]\n        return [neg_values, pos_values]\n\n    def valid_evidence(self, context: str, instantiation) -&gt; tuple[bool, str]:\n        \"\"\"\n        Tests if evidence is a valid instantiation for the context.\n\n        Returns a bool if evidence is valid or not and a string with a error message if not valid.\n        Args:\n            context: a context\n            instantiation: an instantiation of the context\n        Returns:\n            tuple[bool, str]:\n            A tuple of bool to indicate validity and str for error/warn message\n        \"\"\"\n\n        if context not in self.config['contexts']:\n            # If context not known to the config is given in evidence it will just ignore that context.\n            return True, f'Context \"{context}\" not set in config - will be ignored'\n\n        if not isinstance(instantiation, Hashable):\n            # I not hasable, it can't be used!\n            return False, f'Context instatiations must be hashable! Instantiation \"{instantiation}\" for context \"{context}\" is not hashable!'\n\n        if instantiation is None:\n            # instantiation None is possible - in this case the apriori values will be used.\n            return True, f'No instantiation given for context \"{context}\" - A prori values will be used.'\n\n        if not instantiation in self.config['contexts'][context].keys():\n            invalid_msg = f'\"{instantiation}\" is not a valid instantiation for \"{context}\". Using None instead'\n            valid_options = list(self.config[\"contexts\"][context].keys())\n            valid_options_msg = f' Valid options are {valid_options}'\n            return True, invalid_msg + valid_options_msg\n\n        return True, ''\n\n    def bind_discretization_function(self, context, discretization_function):\n        \"\"\"\n        binds a discretization_function to a specific context.\n\n\n        Args:\n            context: One of the possible contexts from the config\n            discretization_function: A discretization function which has to take one parameter and \n                return one of the possible discrete context instantiations.\n        \"\"\"\n        if context not in self.contexts:\n            raise ValueError(\n                f'Cannot bind discretization function to {context}. Context does not exist!')\n        self.discretization_functions[context] = discretization_function\n\n    def infer(self, evidence, normalized=True, decision_threshold=None) -&gt; tuple:\n        '''\n        infers the probabilities for the intentions with given evidence.\n\n        Args:\n            evidence:\n                Evidence to infer the probabilities of all intentions.\n                Evidence can contain context which is not in the config; \n                    it must not contain all possible contexts.\n                Example:\n                    {'speech commands': 'pickup',\n                     'human holding object': True,\n                     'human activity': 'idle'}\n            decision_threshold: a threshold for picking the most likely intention. \n                Must be between 0 and 1. \n                If not given the decision_threshold defined on initialization is taken. \n            normalized: Flag if the returned inference is normalized to sum up to 1.\n        Returns:\n            tuple:\n            Returns the highest ranking intention (or None if decision_threshold is not reached), the decision threshold\n            and a dictionary of intentions and the corresponding probabilities.\n        '''\n        # check if evidence values are in instantiations and create a card form of bnlearn\n        if decision_threshold is None:\n            decision_threshold = self.config['decision_threshold']\n        card_evidence = {}\n        errors = []\n        warning_msgs = []\n        for context, instantiation in evidence.items():\n            valid, err_msg = self.valid_evidence(context, instantiation)\n            if valid:\n                if err_msg:\n                    warning_msgs.append(err_msg)\n                    continue\n                card_evidence[context] = self.value_to_card[context][instantiation]\n            elif context in self.discretization_functions and instantiation is not None:\n                discrete_instantiation = self.discretization_functions[context](\n                    instantiation)\n                valid, err_msg = self.valid_evidence(\n                    context, discrete_instantiation)\n                if valid:\n                    if err_msg:\n                        warning_msgs.append(err_msg)\n                        continue\n                    card_evidence[context] = self.value_to_card[context][discrete_instantiation]\n                else:\n                    errors.append(err_msg)\n            else:\n                errors.append(err_msg)\n\n        if warning_msgs:\n            for warning in warning_msgs:\n                warnings.warn(warning)\n\n        if errors:\n            raise ValueError(f\"{errors}\")\n\n        if self.valid:\n            inference = {}\n            for intention in self.intentions:\n                # only True values of binary intentions will be saved\n                inference[intention] = bn.inference.fit(\n                    self.DAG,\n                    variables=[intention],\n                    evidence=card_evidence,\n                    verbose=self.bn_verbosity\n                ).values[1]\n\n            if normalized:\n                inference = self.normalize_inference(inference)\n            max_intention = max(inference, key=inference.get)\n            max_intention = max_intention if inference[max_intention] &gt; decision_threshold else None\n            return max_intention, decision_threshold, inference\n        else:\n            raise ValueError('Invalid configuration')\n\n    def normalize_inference(self, inference: dict) -&gt; dict:\n        '''\n        Normalizes the inference to a proper probability distribution.\n\n        Inference which is not normalized will be normalized for one intention being True or False,\n        which leads to uninterpretable results for inference of multiple intentions.\n\n        Args:\n            inference: dictionary of intentions and the corresponding probabilities\n        Returns:\n            dict: dictionary of intentions and the corresponding normalized probabilities.\n\n        '''\n        normalized_inference = {}\n        probability_sum = sum(inference.values())\n        for intention, probability in inference.items():\n            normalized_inference[intention] = probability / probability_sum\n        return normalized_inference\n\n    def validate_config(self):\n        '''\n        validate that the current config follows the correct format.\n\n        Raises:\n            Warnings: Warning is raised if the config is not valid.\n\n        Returns: \n            bool: True if config is valid, False otherwise\n        '''\n        # We assume the config is valid - if not this will be set to False - this allows to raise multiple warnings\n        self.valid = True\n        if 'contexts' not in self.config:\n            warnings.warn('Field \"contexts\" must be defined in the config')\n            self.valid = False\n        if 'intentions' not in self.config:\n            warnings.warn('Field \"intentions\" must be defined in the config')\n            self.valid = False\n        if not len(self.config['contexts']):\n            warnings.warn('No contexts defined')\n            self.valid = False\n        if not len(self.config['intentions']):\n            warnings.warn('No intentions defined')\n            self.valid = False\n        if not isinstance(self.config['decision_threshold'], float) or \\\n                not (0 &lt;= self.config['decision_threshold'] &lt; 1):\n            warnings.warn(\n                'Decision threshold must be a number between 0 and 1')\n            self.valid = False\n\n        # Intentions need to have influence value for all contexts and their possible instantiations\n        for intention, context_influences in self.config['intentions'].items():\n            for context, influences in context_influences.items():\n\n                if isinstance(context, str) and context not in self.config['contexts']:\n                    warnings.warn(\n                        f'Context influence {context} cannot be found in the defined contexts!')\n                    self.valid = False\n\n                for instantiation, influence in influences.items():\n                    if not isinstance(instantiation, tuple):\n                        if not (0 &lt;= influence &lt;= 5 and isinstance(influence, int)):\n                            warnings.warn(\n                                f'Influence Value for {intention}.{context}.{instantiation} must be an integer between 0 and 5! Is {influence}')\n                            self.valid = False\n                        if instantiation not in self.config['contexts'][context].keys():\n                            warnings.warn(\n                                f'An influence needs to be defined for all instantiations! {intention}.{context}.{instantiation} does not fit the defined instantiations for {context}')\n                            self.valid = False\n\n        # Probabilities need to sum up to 1\n        for context, instantiations in self.config['contexts'].items():\n            for instantiation, value in instantiations.items():\n                if not isinstance(value, float):\n                    warnings.warn(\n                        f'Apriori probability of context \"{context}.{instantiation}\" is not a number')\n                    self.valid = False\n            if sum(instantiations.values()) != 1.0:\n                warnings.warn(\n                    f'The sum of probabilities for context instantiations must be 1 - For \"{context}\" it is {sum(instantiations.values())}!')\n                self.valid = False\n\n        # This is the config of the currently running BayesNet\n        if self.valid:\n            self.valid_config = deepcopy(self.config)\n        return self.valid\n\n    def _create_zero_influence_dict(self, context_with_instantiations: dict) -&gt; defaultdict:\n        \"\"\"\n        This uses the context dict from config['contexts'] to instantiate a dict that can be used in \n            config['intentions']['some_context']\n\n        Args:\n            context_with_instantiations: \n                a dict holding contexts, their instantiations and corresponding apriori probabilities\n        Returns:\n            defaultdict:\n            A dictionary with zero-initialized influence values for every given context.\n            Example:\n            {some_context:{\n                inst_1:0,\n                inst_2:0,\n                ...\n                inst_3:0\n                }\n            }\n        \"\"\"\n        zeros = defaultdict(lambda: defaultdict(dict))\n        for context, instantiations in context_with_instantiations.items():\n            for instantiation, _ in instantiations.items():\n                zeros[context][instantiation] = 0\n        return zeros\n\n    def add_context(self, context: str, instantiations: dict):\n        \"\"\"\n        This will add a new context to the config and updates the bayesNet.\n\n        Args:\n            context: a new context for the config\n            instantiations:\n                a dict of the instantiations and their corresponding apriori probabilities\n                Example:\n                    {True: 0.6, False:0.4}\n        Raises:\n            ValueError: Raises a ValueError if the context already exists in the config\n        \"\"\"\n        # check if context exists already\n        if context in self.config['contexts']:\n            raise ValueError(\n                'Cannot add existing context - use edit_context to edit an existing context')\n        # fill in the new context\n        self.config['contexts'][context] = instantiations\n        # add this context in every intention with instantiations and values beeing zero.\n        self._transport_context_into_intentions()\n        # reinizialize\n        self.__init__(self.config)\n\n    def add_intention(self, intention: str):\n        \"\"\"\n        This will add a new intention to the config and updates the bayesNet.\n\n        Args:\n            intention: Name of a new intention\n\n        Raises:\n            ValueError: Raises a ValueError if the intention already exists in the config\n        \"\"\"\n        # check if intention exists already\n        if intention in self.config['intentions']:\n            raise ValueError(\n                'Cannot add existing intention - use edit_intention to edit an existing intention')\n        # add in the intention filled with zeros for all contexts\n        self.config['intentions'][intention] = defaultdict(\n            lambda: defaultdict(int))\n        self._transport_context_into_intentions()\n        # for context, instantiations_with_values in self.config['contexts'].items():\n        #     zeros = self._create_zero_influence_dict(\n        #         {context: instantiations_with_values})\n        #     self.config['intentions'][intention][context] = zeros[context]\n        # reinizialize\n        self.__init__(self.config)\n\n    def edit_context(self, context: str, instantiations: dict, new_name: str = None):\n        \"\"\"\n        Edits an existing context - this can also be used to remove instantiations\n\n        !!! note\n            Changing the name of an instantiation will always set the influence value of this \n                instantiation to zero for all intentions!\n\n        Args:\n            context: Name of the context to edit\n            instantiations:\n                A Dict of instantiations and their corresponding apriori probabilities.\n                Example: {True: 0.6, False: 0.4}\n            new_name: A new name for the context\n\n\n        Raises:\n            ValueError: Raises a ValueError if the context does not exists in the config\n        \"\"\"\n        # check if context exists already - only then I can edit\n        if context not in self.config['contexts']:\n            raise ValueError(\n                'Cannot edit non existing context - use add_context to add a new context')\n        if new_name:  # del old names context\n            del self.config['contexts'][context]\n            # rename all occurences in intentions\n            for intention in self.config['intentions']:\n                old_instantiations = deepcopy(\n                    self.config['intentions'][intention][context])\n                del self.config['intentions'][intention][context]\n                self.config['intentions'][intention][new_name] = old_instantiations\n            context = new_name\n\n        self.config['contexts'][context] = instantiations\n        self._remove_context_from_intentions()\n        self._transport_context_into_intentions()\n        # reinizialize\n        self.__init__(self.config)\n\n    def edit_intention(self, intention: str, new_name: str):\n        \"\"\"\n        Edits an existing intention.\n\n        Args:\n            intention: Name of the intention to edit\n            new_name: A new name for the intention\n\n        Raises:\n            ValueError: Raises a ValueError if the intention does not exists in the config\n        \"\"\"\n        # check if context exists already - only then I can edit\n        if intention not in self.config['intentions']:\n            raise ValueError(\n                'Cannot edit non existing intention - use add_intention to add a new intention')\n        if new_name in self.config['intentions']:\n            raise ValueError(\n                f'{new_name} exists - cannot be given as the new name for {intention}')\n        old_values = deepcopy(self.config['intentions'][intention])\n        del self.config['intentions'][intention]\n        self.config['intentions'][new_name] = old_values\n        # reinizialize\n        self.__init__(self.config)\n\n    def del_context(self, context: str):\n        \"\"\"\n        Removes a context.\n\n        Args:\n            context: Name of the context to delete\n\n        Raises:\n            ValueError: An ValueError is raised if the context is not in self.config.\n        \"\"\"\n        # Check if context exists already - only then I can edit\n        if context not in self.config['contexts']:\n            raise ValueError(\n                'Cannot delete non-existing context - use add_context to add a new context')\n\n        del self.config['contexts'][context]\n        self._remove_context_from_intentions()\n        self._transport_context_into_intentions()\n\n        self.__init__(self.config)\n\n    def del_intention(self, intention):\n        \"\"\"\n        remove an intention.\n\n        Args:\n            intention: Name of the intention to delete\n\n        Raises:\n            ValueError: An ValueError is raised if the intention is not in self.config.\n        \"\"\"\n        if intention not in self.config['intentions']:\n            raise ValueError(\n                'Cannot delete non existing intention - use add_intention to add a new intention')\n        del self.config['intentions'][intention]\n        # reinizialize\n        self.__init__(self.config)\n\n    def save(self, path: str, save_invalid: bool = True):\n        \"\"\"\n        saves the config of the bayesNet to a yml file.\n\n        Args:\n            path: path to the file the config will be saved in\n            save_invalid: Flag to decide if invalid configs can be saved\n        Raises:\n            ValueError: \n                A ValueError is raised if `save_invalid` is `False` and the config is not valid\n        \"\"\"\n        if not self.valid and not save_invalid:\n            warnings.warn(\"Invalid configuration will not be saved.\")\n        else:\n            with open(path, 'w', encoding='utf-8') as save_file:\n                yaml.dump(default_to_regular(self.config), save_file)\n\n    def load(self, path: str):\n        \"\"\"\n        Loads a config from file and reinitializes the bayesNet.\n\n        Args:\n            path: path to the file the config is saved in\n        \"\"\"\n        config = load_config(path)\n        # reinitialize with config\n        self.__init__(config)\n\n    def change_context_apriori_value(self, context: str, instantiation, value: float):\n        \"\"\"\n        Changes the apriori_value for a context instantiation.\n\n        Args:\n            context: Name of the context\n            instantiation: The instantiation for which the apriori value needs to be changed\n            value: the new apriori value\n        Raises:\n            ValueError: Raises a ValueError if the instantiation does not exists in the config\n        \"\"\"\n        # check if this value already exists because I'm using defaultdict\n        # otherwise you can just add values\n        if instantiation in self.config['contexts'][context]:\n            self.config['contexts'][context][instantiation] = value\n            # reinizialize\n            self.__init__(self.config)\n        else:\n            raise ValueError(\n                'change_context_apriori_value can only change values that exist already')\n\n    def change_influence_value(self, intention: str, context: str, instantiation, value: int):\n        \"\"\"\n        Update the influence value of a specific intention for a particular context instance..\n\n        Args:\n            intention: Name of the intention\n            context: name of the context\n            instantiation: The instantiation for which the influence value should be changed\n            value: the new influence value. Can be one out of [0, 1, 2, 3, 4, 5]\n        Raises:\n            ValueError: Raises a ValueError if the instantiation does not exists in the config\n        \"\"\"\n        # check if this value already exists because I'm using defaultdict\n        # otherwise you can just add values\n        if instantiation in self.config['intentions'][intention][context]:\n            self.config['intentions'][intention][context][instantiation] = value\n            self.__init__(self.config)\n        else:\n            raise ValueError(\n                'change_influence_value can only change values that exist already')\n\n    def add_combined_influence(self, intention: str, contexts: tuple,\n                               instantiations: tuple, value: int):\n        \"\"\"\n        Adds an influence value for a combination of context instantiations.\n\n        Args:\n            intention: Name of the intention\n            contexts: tuple containing the names of the contexts\n            instantiations: Tuple of context instances to set influence value for.\n            value: influence value. Can be one out of [0, 1, 2, 3, 4, 5]\n        Raises:\n            ValueError: Raises a ValueError if the instantiation does not exists in the config\n        \"\"\"\n        if not contexts:\n            raise ValueError('Contexts list cannot be empty.')\n        if intention not in self.config['intentions']:\n            raise ValueError(\n                f'\"{intention}\" does not exist in the list of intentions')\n        for i, instantiation in enumerate(instantiations):\n            if instantiation not in self.config['intentions'][intention][contexts[i]]:\n                raise ValueError(\n                    'add_combined_influence can only combine context instantiations that already exist')\n        self.config['intentions'][intention][contexts][instantiations] = value\n        self.__init__(self.config)\n\n    def del_combined_influence(self, intention: str, contexts: tuple, instantiations: tuple):\n        \"\"\"\n        Adds an influence value for a combination of context instantiations.\n\n        Args:\n            intention: Name of the intention\n            contexts: tuple containing the names of the contexts\n            instantiations: tuple of context instantiations\n        Raises:\n            ValueError: Raises a ValueError if the instantiation does not exists in the config\n        \"\"\"\n        if instantiations not in self.config['intentions'][intention][contexts]:\n            raise ValueError(\n                'Combined context instantiations must exist to be removed.')\n        del self.config['intentions'][intention][contexts]\n\n    def _transport_context_into_intentions(self):\n        \"\"\"\n        Transports contexts and their instantiations defined in the config['contexts'] into \n            config['intentions'] as influencing context if not present.\n        \"\"\"\n        for context in self.config['contexts']:\n            for instantiation in self.config['contexts'][context]:\n                for intention in self.config['intentions']:\n                    if instantiation not in self.config['intentions'][intention][context]:\n                        # This only works if it is a defaultdict\n                        self.config['intentions'][intention][context][instantiation] = 0\n\n    def _remove_context_from_intentions(self):\n        \"\"\"\n        This removes context or instantiation after removing/changing instantiations and/or context.\n        \"\"\"\n        # This is a hack because you can't edit while iterating a dict\n        contexts_to_remove_from_intentions = []\n        context_instantiations_to_remove_from_intentions = []\n        for intention in self.config['intentions']:\n            for context in self.config['intentions'][intention]:\n                if context not in self.config['contexts']:\n                    contexts_to_remove_from_intentions.append(\n                        (intention, context))\n                else:\n                    for instantiation in self.config['intentions'][intention][context]:\n                        if instantiation not in self.config['contexts'][context]:\n                            context_instantiations_to_remove_from_intentions.append(\n                                (intention, context, instantiation))\n        for intention, context in contexts_to_remove_from_intentions:\n            del self.config['intentions'][intention][context]\n        for intention, context, instantiation in context_instantiations_to_remove_from_intentions:\n            del self.config['intentions'][intention][context][instantiation]\n\n    def change_decision_threshold(self, decision_threshold):\n        \"\"\"\n        Changes the decision threshold in the config.\n        Args:\n            decision_threshold: The new decision threshold.\n        \"\"\"\n        self.config['decision_threshold'] = decision_threshold\n        self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.__init__","title":"<code>__init__(self, config=None, bn_verbosity=0, validate=True)</code>  <code>special</code>","text":"<p>Initializes the BayesNet with the given config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A dict with a config following the config format.</p> <code>None</code> <code>bn_verbosity</code> <code>int</code> <p>sets the verbose flag for bnlearn. See [bnlearn API]( https://erdogant.github.io/bnlearn/pages/html/bnlearn.bnlearn.html?highlight=verbose</p> <code>0</code> <code>validate</code> <code>bool</code> <p>Flag if the given config should be validated or not.  This is necessary to load invalid configs</p> <code>True</code> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def __init__(self, config: dict = None, bn_verbosity: int = 0, validate: bool = True) -&gt; None:\n    '''\n    Initializes the BayesNet with the given config.\n\n    Args:\n        config: A dict with a config following the config format.\n        bn_verbosity: sets the verbose flag for bnlearn. See [bnlearn API](\n            https://erdogant.github.io/bnlearn/pages/html/bnlearn.bnlearn.html?highlight=verbose\n            #bnlearn.bnlearn.make_DAG) for more information\n        validate: Flag if the given config should be validated or not. \n            This is necessary to load invalid configs\n    '''\n    self.log = logging.getLogger(self.__class__.__name__)\n\n    self.valid = False\n    self.bn_verbosity = bn_verbosity\n    self.discretization_functions = {}\n\n    if config is None:\n        validate = False\n    config = config_to_default_dict(config)\n\n    # if not config:\n    #     self.config = {'intentions': defaultdict(lambda: defaultdict(\n    #         lambda: defaultdict(int))), 'contexts': defaultdict(lambda: defaultdict(float))}\n    #     return\n\n    self.config = deepcopy(config)\n    self.decision_threshold = self.config['decision_threshold']\n\n    if validate:\n        self.validate_config()\n\n    # Translation dicts for context to card number in bnlearn and vice versa\n    self._create_value_to_card()\n    self._create_card_to_value()\n    # Translation dict for the std values to probabilities\n    self.value_to_prob = {5: 0.95, 4: 0.75,\n                          3: 0.5, 2: 0.25, 1: 0.05, 0: 0.0}\n\n    # initialize the bayes net structure\n    self.contexts = self.evidence = list(self.config['contexts'].keys())\n    self.intentions = list(self.config['intentions'].keys())\n    self.edges = list(itertools.product(self.contexts, self.intentions))\n    self._create_evidence_card()\n\n    # create CPTs for the bayes net\n    self.cpts = []\n    self._create_context_cpts()\n    self._create_intention_cpts()\n    if self.valid:\n        self.DAG = bn.make_DAG(self.edges, CPD=self.cpts,\n                               verbose=self.bn_verbosity)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.__init__--bnlearnbnlearnmake_dag-for-more-information","title":"bnlearn.bnlearn.make_DAG) for more information","text":""},{"location":"API/#CoBaIR.bayes_net.BayesNet.add_combined_influence","title":"<code>add_combined_influence(self, intention, contexts, instantiations, value)</code>","text":"<p>Adds an influence value for a combination of context instantiations.</p> <p>Parameters:</p> Name Type Description Default <code>intention</code> <code>str</code> <p>Name of the intention</p> required <code>contexts</code> <code>tuple</code> <p>tuple containing the names of the contexts</p> required <code>instantiations</code> <code>tuple</code> <p>Tuple of context instances to set influence value for.</p> required <code>value</code> <code>int</code> <p>influence value. Can be one out of [0, 1, 2, 3, 4, 5]</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises a ValueError if the instantiation does not exists in the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def add_combined_influence(self, intention: str, contexts: tuple,\n                           instantiations: tuple, value: int):\n    \"\"\"\n    Adds an influence value for a combination of context instantiations.\n\n    Args:\n        intention: Name of the intention\n        contexts: tuple containing the names of the contexts\n        instantiations: Tuple of context instances to set influence value for.\n        value: influence value. Can be one out of [0, 1, 2, 3, 4, 5]\n    Raises:\n        ValueError: Raises a ValueError if the instantiation does not exists in the config\n    \"\"\"\n    if not contexts:\n        raise ValueError('Contexts list cannot be empty.')\n    if intention not in self.config['intentions']:\n        raise ValueError(\n            f'\"{intention}\" does not exist in the list of intentions')\n    for i, instantiation in enumerate(instantiations):\n        if instantiation not in self.config['intentions'][intention][contexts[i]]:\n            raise ValueError(\n                'add_combined_influence can only combine context instantiations that already exist')\n    self.config['intentions'][intention][contexts][instantiations] = value\n    self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.add_context","title":"<code>add_context(self, context, instantiations)</code>","text":"<p>This will add a new context to the config and updates the bayesNet.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>a new context for the config</p> required <code>instantiations</code> <code>dict</code> <p>a dict of the instantiations and their corresponding apriori probabilities Example:     {True: 0.6, False:0.4}</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises a ValueError if the context already exists in the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def add_context(self, context: str, instantiations: dict):\n    \"\"\"\n    This will add a new context to the config and updates the bayesNet.\n\n    Args:\n        context: a new context for the config\n        instantiations:\n            a dict of the instantiations and their corresponding apriori probabilities\n            Example:\n                {True: 0.6, False:0.4}\n    Raises:\n        ValueError: Raises a ValueError if the context already exists in the config\n    \"\"\"\n    # check if context exists already\n    if context in self.config['contexts']:\n        raise ValueError(\n            'Cannot add existing context - use edit_context to edit an existing context')\n    # fill in the new context\n    self.config['contexts'][context] = instantiations\n    # add this context in every intention with instantiations and values beeing zero.\n    self._transport_context_into_intentions()\n    # reinizialize\n    self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.add_intention","title":"<code>add_intention(self, intention)</code>","text":"<p>This will add a new intention to the config and updates the bayesNet.</p> <p>Parameters:</p> Name Type Description Default <code>intention</code> <code>str</code> <p>Name of a new intention</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises a ValueError if the intention already exists in the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def add_intention(self, intention: str):\n    \"\"\"\n    This will add a new intention to the config and updates the bayesNet.\n\n    Args:\n        intention: Name of a new intention\n\n    Raises:\n        ValueError: Raises a ValueError if the intention already exists in the config\n    \"\"\"\n    # check if intention exists already\n    if intention in self.config['intentions']:\n        raise ValueError(\n            'Cannot add existing intention - use edit_intention to edit an existing intention')\n    # add in the intention filled with zeros for all contexts\n    self.config['intentions'][intention] = defaultdict(\n        lambda: defaultdict(int))\n    self._transport_context_into_intentions()\n    # for context, instantiations_with_values in self.config['contexts'].items():\n    #     zeros = self._create_zero_influence_dict(\n    #         {context: instantiations_with_values})\n    #     self.config['intentions'][intention][context] = zeros[context]\n    # reinizialize\n    self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.bind_discretization_function","title":"<code>bind_discretization_function(self, context, discretization_function)</code>","text":"<p>binds a discretization_function to a specific context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <p>One of the possible contexts from the config</p> required <code>discretization_function</code> <p>A discretization function which has to take one parameter and  return one of the possible discrete context instantiations.</p> required Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def bind_discretization_function(self, context, discretization_function):\n    \"\"\"\n    binds a discretization_function to a specific context.\n\n\n    Args:\n        context: One of the possible contexts from the config\n        discretization_function: A discretization function which has to take one parameter and \n            return one of the possible discrete context instantiations.\n    \"\"\"\n    if context not in self.contexts:\n        raise ValueError(\n            f'Cannot bind discretization function to {context}. Context does not exist!')\n    self.discretization_functions[context] = discretization_function\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.change_context_apriori_value","title":"<code>change_context_apriori_value(self, context, instantiation, value)</code>","text":"<p>Changes the apriori_value for a context instantiation.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>Name of the context</p> required <code>instantiation</code> <p>The instantiation for which the apriori value needs to be changed</p> required <code>value</code> <code>float</code> <p>the new apriori value</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises a ValueError if the instantiation does not exists in the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def change_context_apriori_value(self, context: str, instantiation, value: float):\n    \"\"\"\n    Changes the apriori_value for a context instantiation.\n\n    Args:\n        context: Name of the context\n        instantiation: The instantiation for which the apriori value needs to be changed\n        value: the new apriori value\n    Raises:\n        ValueError: Raises a ValueError if the instantiation does not exists in the config\n    \"\"\"\n    # check if this value already exists because I'm using defaultdict\n    # otherwise you can just add values\n    if instantiation in self.config['contexts'][context]:\n        self.config['contexts'][context][instantiation] = value\n        # reinizialize\n        self.__init__(self.config)\n    else:\n        raise ValueError(\n            'change_context_apriori_value can only change values that exist already')\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.change_decision_threshold","title":"<code>change_decision_threshold(self, decision_threshold)</code>","text":"<p>Changes the decision threshold in the config.</p> <p>Parameters:</p> Name Type Description Default <code>decision_threshold</code> <p>The new decision threshold.</p> required Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def change_decision_threshold(self, decision_threshold):\n    \"\"\"\n    Changes the decision threshold in the config.\n    Args:\n        decision_threshold: The new decision threshold.\n    \"\"\"\n    self.config['decision_threshold'] = decision_threshold\n    self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.change_influence_value","title":"<code>change_influence_value(self, intention, context, instantiation, value)</code>","text":"<p>Update the influence value of a specific intention for a particular context instance..</p> <p>Parameters:</p> Name Type Description Default <code>intention</code> <code>str</code> <p>Name of the intention</p> required <code>context</code> <code>str</code> <p>name of the context</p> required <code>instantiation</code> <p>The instantiation for which the influence value should be changed</p> required <code>value</code> <code>int</code> <p>the new influence value. Can be one out of [0, 1, 2, 3, 4, 5]</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises a ValueError if the instantiation does not exists in the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def change_influence_value(self, intention: str, context: str, instantiation, value: int):\n    \"\"\"\n    Update the influence value of a specific intention for a particular context instance..\n\n    Args:\n        intention: Name of the intention\n        context: name of the context\n        instantiation: The instantiation for which the influence value should be changed\n        value: the new influence value. Can be one out of [0, 1, 2, 3, 4, 5]\n    Raises:\n        ValueError: Raises a ValueError if the instantiation does not exists in the config\n    \"\"\"\n    # check if this value already exists because I'm using defaultdict\n    # otherwise you can just add values\n    if instantiation in self.config['intentions'][intention][context]:\n        self.config['intentions'][intention][context][instantiation] = value\n        self.__init__(self.config)\n    else:\n        raise ValueError(\n            'change_influence_value can only change values that exist already')\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.del_combined_influence","title":"<code>del_combined_influence(self, intention, contexts, instantiations)</code>","text":"<p>Adds an influence value for a combination of context instantiations.</p> <p>Parameters:</p> Name Type Description Default <code>intention</code> <code>str</code> <p>Name of the intention</p> required <code>contexts</code> <code>tuple</code> <p>tuple containing the names of the contexts</p> required <code>instantiations</code> <code>tuple</code> <p>tuple of context instantiations</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises a ValueError if the instantiation does not exists in the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def del_combined_influence(self, intention: str, contexts: tuple, instantiations: tuple):\n    \"\"\"\n    Adds an influence value for a combination of context instantiations.\n\n    Args:\n        intention: Name of the intention\n        contexts: tuple containing the names of the contexts\n        instantiations: tuple of context instantiations\n    Raises:\n        ValueError: Raises a ValueError if the instantiation does not exists in the config\n    \"\"\"\n    if instantiations not in self.config['intentions'][intention][contexts]:\n        raise ValueError(\n            'Combined context instantiations must exist to be removed.')\n    del self.config['intentions'][intention][contexts]\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.del_context","title":"<code>del_context(self, context)</code>","text":"<p>Removes a context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>Name of the context to delete</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>An ValueError is raised if the context is not in self.config.</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def del_context(self, context: str):\n    \"\"\"\n    Removes a context.\n\n    Args:\n        context: Name of the context to delete\n\n    Raises:\n        ValueError: An ValueError is raised if the context is not in self.config.\n    \"\"\"\n    # Check if context exists already - only then I can edit\n    if context not in self.config['contexts']:\n        raise ValueError(\n            'Cannot delete non-existing context - use add_context to add a new context')\n\n    del self.config['contexts'][context]\n    self._remove_context_from_intentions()\n    self._transport_context_into_intentions()\n\n    self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.del_intention","title":"<code>del_intention(self, intention)</code>","text":"<p>remove an intention.</p> <p>Parameters:</p> Name Type Description Default <code>intention</code> <p>Name of the intention to delete</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>An ValueError is raised if the intention is not in self.config.</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def del_intention(self, intention):\n    \"\"\"\n    remove an intention.\n\n    Args:\n        intention: Name of the intention to delete\n\n    Raises:\n        ValueError: An ValueError is raised if the intention is not in self.config.\n    \"\"\"\n    if intention not in self.config['intentions']:\n        raise ValueError(\n            'Cannot delete non existing intention - use add_intention to add a new intention')\n    del self.config['intentions'][intention]\n    # reinizialize\n    self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.edit_context","title":"<code>edit_context(self, context, instantiations, new_name=None)</code>","text":"<p>Edits an existing context - this can also be used to remove instantiations</p> <p>Note</p> <p>Changing the name of an instantiation will always set the influence value of this      instantiation to zero for all intentions!</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>Name of the context to edit</p> required <code>instantiations</code> <code>dict</code> <p>A Dict of instantiations and their corresponding apriori probabilities. Example: {True: 0.6, False: 0.4}</p> required <code>new_name</code> <code>str</code> <p>A new name for the context</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises a ValueError if the context does not exists in the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def edit_context(self, context: str, instantiations: dict, new_name: str = None):\n    \"\"\"\n    Edits an existing context - this can also be used to remove instantiations\n\n    !!! note\n        Changing the name of an instantiation will always set the influence value of this \n            instantiation to zero for all intentions!\n\n    Args:\n        context: Name of the context to edit\n        instantiations:\n            A Dict of instantiations and their corresponding apriori probabilities.\n            Example: {True: 0.6, False: 0.4}\n        new_name: A new name for the context\n\n\n    Raises:\n        ValueError: Raises a ValueError if the context does not exists in the config\n    \"\"\"\n    # check if context exists already - only then I can edit\n    if context not in self.config['contexts']:\n        raise ValueError(\n            'Cannot edit non existing context - use add_context to add a new context')\n    if new_name:  # del old names context\n        del self.config['contexts'][context]\n        # rename all occurences in intentions\n        for intention in self.config['intentions']:\n            old_instantiations = deepcopy(\n                self.config['intentions'][intention][context])\n            del self.config['intentions'][intention][context]\n            self.config['intentions'][intention][new_name] = old_instantiations\n        context = new_name\n\n    self.config['contexts'][context] = instantiations\n    self._remove_context_from_intentions()\n    self._transport_context_into_intentions()\n    # reinizialize\n    self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.edit_intention","title":"<code>edit_intention(self, intention, new_name)</code>","text":"<p>Edits an existing intention.</p> <p>Parameters:</p> Name Type Description Default <code>intention</code> <code>str</code> <p>Name of the intention to edit</p> required <code>new_name</code> <code>str</code> <p>A new name for the intention</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises a ValueError if the intention does not exists in the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def edit_intention(self, intention: str, new_name: str):\n    \"\"\"\n    Edits an existing intention.\n\n    Args:\n        intention: Name of the intention to edit\n        new_name: A new name for the intention\n\n    Raises:\n        ValueError: Raises a ValueError if the intention does not exists in the config\n    \"\"\"\n    # check if context exists already - only then I can edit\n    if intention not in self.config['intentions']:\n        raise ValueError(\n            'Cannot edit non existing intention - use add_intention to add a new intention')\n    if new_name in self.config['intentions']:\n        raise ValueError(\n            f'{new_name} exists - cannot be given as the new name for {intention}')\n    old_values = deepcopy(self.config['intentions'][intention])\n    del self.config['intentions'][intention]\n    self.config['intentions'][new_name] = old_values\n    # reinizialize\n    self.__init__(self.config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.infer","title":"<code>infer(self, evidence, normalized=True, decision_threshold=None)</code>","text":"<p>infers the probabilities for the intentions with given evidence.</p> <p>Parameters:</p> Name Type Description Default <code>evidence</code> <p>Evidence to infer the probabilities of all intentions. Evidence can contain context which is not in the config;      it must not contain all possible contexts. Example:     {'speech commands': 'pickup',      'human holding object': True,      'human activity': 'idle'}</p> required <code>decision_threshold</code> <p>a threshold for picking the most likely intention.  Must be between 0 and 1.  If not given the decision_threshold defined on initialization is taken. </p> <code>None</code> <code>normalized</code> <p>Flag if the returned inference is normalized to sum up to 1.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Returns the highest ranking intention (or None if decision_threshold is not reached), the decision threshold and a dictionary of intentions and the corresponding probabilities.</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def infer(self, evidence, normalized=True, decision_threshold=None) -&gt; tuple:\n    '''\n    infers the probabilities for the intentions with given evidence.\n\n    Args:\n        evidence:\n            Evidence to infer the probabilities of all intentions.\n            Evidence can contain context which is not in the config; \n                it must not contain all possible contexts.\n            Example:\n                {'speech commands': 'pickup',\n                 'human holding object': True,\n                 'human activity': 'idle'}\n        decision_threshold: a threshold for picking the most likely intention. \n            Must be between 0 and 1. \n            If not given the decision_threshold defined on initialization is taken. \n        normalized: Flag if the returned inference is normalized to sum up to 1.\n    Returns:\n        tuple:\n        Returns the highest ranking intention (or None if decision_threshold is not reached), the decision threshold\n        and a dictionary of intentions and the corresponding probabilities.\n    '''\n    # check if evidence values are in instantiations and create a card form of bnlearn\n    if decision_threshold is None:\n        decision_threshold = self.config['decision_threshold']\n    card_evidence = {}\n    errors = []\n    warning_msgs = []\n    for context, instantiation in evidence.items():\n        valid, err_msg = self.valid_evidence(context, instantiation)\n        if valid:\n            if err_msg:\n                warning_msgs.append(err_msg)\n                continue\n            card_evidence[context] = self.value_to_card[context][instantiation]\n        elif context in self.discretization_functions and instantiation is not None:\n            discrete_instantiation = self.discretization_functions[context](\n                instantiation)\n            valid, err_msg = self.valid_evidence(\n                context, discrete_instantiation)\n            if valid:\n                if err_msg:\n                    warning_msgs.append(err_msg)\n                    continue\n                card_evidence[context] = self.value_to_card[context][discrete_instantiation]\n            else:\n                errors.append(err_msg)\n        else:\n            errors.append(err_msg)\n\n    if warning_msgs:\n        for warning in warning_msgs:\n            warnings.warn(warning)\n\n    if errors:\n        raise ValueError(f\"{errors}\")\n\n    if self.valid:\n        inference = {}\n        for intention in self.intentions:\n            # only True values of binary intentions will be saved\n            inference[intention] = bn.inference.fit(\n                self.DAG,\n                variables=[intention],\n                evidence=card_evidence,\n                verbose=self.bn_verbosity\n            ).values[1]\n\n        if normalized:\n            inference = self.normalize_inference(inference)\n        max_intention = max(inference, key=inference.get)\n        max_intention = max_intention if inference[max_intention] &gt; decision_threshold else None\n        return max_intention, decision_threshold, inference\n    else:\n        raise ValueError('Invalid configuration')\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.load","title":"<code>load(self, path)</code>","text":"<p>Loads a config from file and reinitializes the bayesNet.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to the file the config is saved in</p> required Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def load(self, path: str):\n    \"\"\"\n    Loads a config from file and reinitializes the bayesNet.\n\n    Args:\n        path: path to the file the config is saved in\n    \"\"\"\n    config = load_config(path)\n    # reinitialize with config\n    self.__init__(config)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.normalize_inference","title":"<code>normalize_inference(self, inference)</code>","text":"<p>Normalizes the inference to a proper probability distribution.</p> <p>Inference which is not normalized will be normalized for one intention being True or False, which leads to uninterpretable results for inference of multiple intentions.</p> <p>Parameters:</p> Name Type Description Default <code>inference</code> <code>dict</code> <p>dictionary of intentions and the corresponding probabilities</p> required <p>Returns:</p> Type Description <code>dict</code> <p>dictionary of intentions and the corresponding normalized probabilities.</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def normalize_inference(self, inference: dict) -&gt; dict:\n    '''\n    Normalizes the inference to a proper probability distribution.\n\n    Inference which is not normalized will be normalized for one intention being True or False,\n    which leads to uninterpretable results for inference of multiple intentions.\n\n    Args:\n        inference: dictionary of intentions and the corresponding probabilities\n    Returns:\n        dict: dictionary of intentions and the corresponding normalized probabilities.\n\n    '''\n    normalized_inference = {}\n    probability_sum = sum(inference.values())\n    for intention, probability in inference.items():\n        normalized_inference[intention] = probability / probability_sum\n    return normalized_inference\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.save","title":"<code>save(self, path, save_invalid=True)</code>","text":"<p>saves the config of the bayesNet to a yml file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to the file the config will be saved in</p> required <code>save_invalid</code> <code>bool</code> <p>Flag to decide if invalid configs can be saved</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>A ValueError is raised if <code>save_invalid</code> is <code>False</code> and the config is not valid</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def save(self, path: str, save_invalid: bool = True):\n    \"\"\"\n    saves the config of the bayesNet to a yml file.\n\n    Args:\n        path: path to the file the config will be saved in\n        save_invalid: Flag to decide if invalid configs can be saved\n    Raises:\n        ValueError: \n            A ValueError is raised if `save_invalid` is `False` and the config is not valid\n    \"\"\"\n    if not self.valid and not save_invalid:\n        warnings.warn(\"Invalid configuration will not be saved.\")\n    else:\n        with open(path, 'w', encoding='utf-8') as save_file:\n            yaml.dump(default_to_regular(self.config), save_file)\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.valid_evidence","title":"<code>valid_evidence(self, context, instantiation)</code>","text":"<p>Tests if evidence is a valid instantiation for the context.</p> <p>Returns a bool if evidence is valid or not and a string with a error message if not valid.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>a context</p> required <code>instantiation</code> <p>an instantiation of the context</p> required <p>Returns:</p> Type Description <code>tuple[bool, str]</code> <p>A tuple of bool to indicate validity and str for error/warn message</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def valid_evidence(self, context: str, instantiation) -&gt; tuple[bool, str]:\n    \"\"\"\n    Tests if evidence is a valid instantiation for the context.\n\n    Returns a bool if evidence is valid or not and a string with a error message if not valid.\n    Args:\n        context: a context\n        instantiation: an instantiation of the context\n    Returns:\n        tuple[bool, str]:\n        A tuple of bool to indicate validity and str for error/warn message\n    \"\"\"\n\n    if context not in self.config['contexts']:\n        # If context not known to the config is given in evidence it will just ignore that context.\n        return True, f'Context \"{context}\" not set in config - will be ignored'\n\n    if not isinstance(instantiation, Hashable):\n        # I not hasable, it can't be used!\n        return False, f'Context instatiations must be hashable! Instantiation \"{instantiation}\" for context \"{context}\" is not hashable!'\n\n    if instantiation is None:\n        # instantiation None is possible - in this case the apriori values will be used.\n        return True, f'No instantiation given for context \"{context}\" - A prori values will be used.'\n\n    if not instantiation in self.config['contexts'][context].keys():\n        invalid_msg = f'\"{instantiation}\" is not a valid instantiation for \"{context}\". Using None instead'\n        valid_options = list(self.config[\"contexts\"][context].keys())\n        valid_options_msg = f' Valid options are {valid_options}'\n        return True, invalid_msg + valid_options_msg\n\n    return True, ''\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.BayesNet.validate_config","title":"<code>validate_config(self)</code>","text":"<p>validate that the current config follows the correct format.</p> <p>Exceptions:</p> Type Description <code>Warnings</code> <p>Warning is raised if the config is not valid.</p> <p>Returns:      bool: True if config is valid, False otherwise</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def validate_config(self):\n    '''\n    validate that the current config follows the correct format.\n\n    Raises:\n        Warnings: Warning is raised if the config is not valid.\n\n    Returns: \n        bool: True if config is valid, False otherwise\n    '''\n    # We assume the config is valid - if not this will be set to False - this allows to raise multiple warnings\n    self.valid = True\n    if 'contexts' not in self.config:\n        warnings.warn('Field \"contexts\" must be defined in the config')\n        self.valid = False\n    if 'intentions' not in self.config:\n        warnings.warn('Field \"intentions\" must be defined in the config')\n        self.valid = False\n    if not len(self.config['contexts']):\n        warnings.warn('No contexts defined')\n        self.valid = False\n    if not len(self.config['intentions']):\n        warnings.warn('No intentions defined')\n        self.valid = False\n    if not isinstance(self.config['decision_threshold'], float) or \\\n            not (0 &lt;= self.config['decision_threshold'] &lt; 1):\n        warnings.warn(\n            'Decision threshold must be a number between 0 and 1')\n        self.valid = False\n\n    # Intentions need to have influence value for all contexts and their possible instantiations\n    for intention, context_influences in self.config['intentions'].items():\n        for context, influences in context_influences.items():\n\n            if isinstance(context, str) and context not in self.config['contexts']:\n                warnings.warn(\n                    f'Context influence {context} cannot be found in the defined contexts!')\n                self.valid = False\n\n            for instantiation, influence in influences.items():\n                if not isinstance(instantiation, tuple):\n                    if not (0 &lt;= influence &lt;= 5 and isinstance(influence, int)):\n                        warnings.warn(\n                            f'Influence Value for {intention}.{context}.{instantiation} must be an integer between 0 and 5! Is {influence}')\n                        self.valid = False\n                    if instantiation not in self.config['contexts'][context].keys():\n                        warnings.warn(\n                            f'An influence needs to be defined for all instantiations! {intention}.{context}.{instantiation} does not fit the defined instantiations for {context}')\n                        self.valid = False\n\n    # Probabilities need to sum up to 1\n    for context, instantiations in self.config['contexts'].items():\n        for instantiation, value in instantiations.items():\n            if not isinstance(value, float):\n                warnings.warn(\n                    f'Apriori probability of context \"{context}.{instantiation}\" is not a number')\n                self.valid = False\n        if sum(instantiations.values()) != 1.0:\n            warnings.warn(\n                f'The sum of probabilities for context instantiations must be 1 - For \"{context}\" it is {sum(instantiations.values())}!')\n            self.valid = False\n\n    # This is the config of the currently running BayesNet\n    if self.valid:\n        self.valid_config = deepcopy(self.config)\n    return self.valid\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.PrettySafeLoader","title":"<code> PrettySafeLoader            (SafeLoader)         </code>","text":"<p>A YAML loader that constructs Python tuples from YAML sequences.</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>class PrettySafeLoader(yaml.SafeLoader):\n    \"\"\"A YAML loader that constructs Python tuples from YAML sequences.\"\"\"\n\n    def construct_python_tuple(self, node):\n        \"\"\"\n        Construct a Python tuple from a YAML sequence node.\n\n        Args:\n            node (Any): The YAML sequence node to construct a tuple from.\n\n        Returns:\n            tuple: The constructed tuple.\n        \"\"\"\n        return tuple(self.construct_sequence(node))\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.PrettySafeLoader.construct_python_tuple","title":"<code>construct_python_tuple(self, node)</code>","text":"<p>Construct a Python tuple from a YAML sequence node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>The YAML sequence node to construct a tuple from.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The constructed tuple.</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def construct_python_tuple(self, node):\n    \"\"\"\n    Construct a Python tuple from a YAML sequence node.\n\n    Args:\n        node (Any): The YAML sequence node to construct a tuple from.\n\n    Returns:\n        tuple: The constructed tuple.\n    \"\"\"\n    return tuple(self.construct_sequence(node))\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.config_to_default_dict","title":"<code>config_to_default_dict(config=None)</code>","text":"<p>This casts a config given as dict into a defaultdict.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A dict with a config following the config format.</p> <code>None</code> <p>Returns:</p> Type Description <code>defaultdict</code> <p>a defaultdict containing the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def config_to_default_dict(config: dict = None):\n    \"\"\"\n    This casts a config given as dict into a defaultdict.\n\n    Args:\n        config: A dict with a config following the config format.\n    Returns:\n        defaultdict:\n            a defaultdict containing the config\n    \"\"\"\n    if not config:\n        config = {}\n    new_config = {'intentions': defaultdict(lambda: defaultdict(\n        lambda: defaultdict(int))), 'contexts': defaultdict(lambda: defaultdict(float))}\n    if 'contexts' in config:\n        for context in config['contexts']:\n            for instantiation, value in config['contexts'][context].items():\n                new_config['contexts'][context][instantiation] = value\n    if 'intentions' in config:\n        for intention in config['intentions']:\n            # HERE: there is the chance that there is no context yet - write intention once\n            new_config['intentions'][intention] = defaultdict(\n                lambda: defaultdict(int))\n            for context in config['intentions'][intention]:\n                for instantiation, value in config['intentions'][intention][context].items():\n                    new_config['intentions'][intention][context][instantiation] = value\n    if 'decision_threshold' in config:\n        new_config['decision_threshold'] = config['decision_threshold']\n    else:\n        new_config['decision_threshold'] = 0.0\n\n    return new_config\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.default_to_regular","title":"<code>default_to_regular(d)</code>","text":"<p>This casts a defaultdict to a regular dict which is needed for saving as yml file.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <p>the dict which should be casted</p> required <p>Returns:</p> Type Description <code>dict</code> <p>a regular dict casted from the defaultdict</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def default_to_regular(d):\n    \"\"\"\n    This casts a defaultdict to a regular dict which is needed for saving as yml file.\n\n    Args:\n        d: the dict which should be casted\n    Returns:\n        dict:\n            a regular dict casted from the defaultdict\n    \"\"\"\n    # casts dicts or default dicts because otherwise it will stop at the first dict and\n    # if that has another defaultdict in it - that won't cast\n    if isinstance(d, defaultdict) or isinstance(d, dict):\n        d = {\n            k: default_to_regular(v)\n            for k, v in d.items()\n            if not isinstance(v, dict) or v or isinstance(v, defaultdict)\n        }\n    return d\n</code></pre>"},{"location":"API/#CoBaIR.bayes_net.load_config","title":"<code>load_config(path)</code>","text":"<p>Helper function to load a config.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>path to the file the config is saved in</p> required <p>Returns:</p> Type Description <code>defaultdict</code> <p>a defaultdict containing the config</p> Source code in <code>CoBaIR/bayes_net.py</code> <pre><code>def load_config(path):\n    \"\"\"\n    Helper function to load a config.\n\n    Args:\n        path: path to the file the config is saved in\n    Returns:\n        defaultdict:\n            a defaultdict containing the config\n    \"\"\"\n\n    # if os.path.splitext(path)[-1] != \".yml\":\n    #     raise TypeError(\n    #         'Invalid format file - only supporting yml files')\n    with open(path, encoding='utf-8') as stream:\n        return config_to_default_dict(yaml.load(stream, Loader=PrettySafeLoader))\n</code></pre>"},{"location":"Tutorial/","title":"Tutorial","text":""},{"location":"Tutorial/#purpose-of-cobair","title":"Purpose of CoBaIR","text":"<p>The CoBaIR framework is designed to interpret human intentions within diverse settings, assigning probabilities to these intentions based on the contextual information provided in multimodal scenarios.</p>"},{"location":"Tutorial/#prerequisites","title":"Prerequisites","text":"<p>Before starting to design a scenario with CoBaIR you need to understand some basics.</p>"},{"location":"Tutorial/#intentions","title":"Intentions","text":"<p>Intentions denote what a human in an HRI scenario wants to do in a certain situation. An intention is a binary value e.g. <code>repair pipe</code> that can either be present or not. Only one intention can be present at a time.</p>"},{"location":"Tutorial/#context","title":"Context","text":"<p>Every perceivable aspect of the scenario is considered to be context in CoBaIR. Context can have multiple discrete instantiations e.g. <code>weather:sunny|cloudy|raining</code>. If context values are continuous, discretizer functions can be used to create discrete values.</p>"},{"location":"Tutorial/#configuring-a-cobair-scenario-with-the-gui","title":"Configuring a CoBaIR Scenario with the GUI","text":""},{"location":"Tutorial/#apriori-probabilities","title":"Apriori Probabilities","text":"<p>Apriori probabilities are initial probabilities based on prior knowledge or assumptions, indicating the likelihood of context states. These apriori probabilities will be used during inference if a specific context cannot be observed. In this case it assumed that the instantiations of the context occur with the given probabilities.  </p>"},{"location":"Tutorial/#setting-apriori-probabilities","title":"Setting Apriori Probabilities","text":"<p>In the `Apriori Probability of Context`` section: 1. Select a context or create a new one. 2. Assign probabilities ensuring they sum to 1.</p> <p></p>"},{"location":"Tutorial/#influence-values","title":"Influence Values","text":"<p>These values indicate how much a context influences a particular intention.</p>"},{"location":"Tutorial/#setting-influence-values","title":"Setting Influence Values","text":"<p>In the <code>Influence of Context on Intention</code> area: 1. Choose a context and an intention. 2. Use a slider to assign an influence value on a 0-5 scale.</p> <p></p>"},{"location":"Tutorial/#decision-threshold","title":"Decision Threshold","text":"<p>A pre-set level that an intention must meet or exceed to be selected.</p>"},{"location":"Tutorial/#importance-of-setting-it","title":"Importance of Setting It","text":"<p>It ensures the system acts on intentions with a certain confidence level, reducing the chance of incorrect actions based on low-probability guesses.</p>"},{"location":"Tutorial/#how-to-set","title":"How to Set","text":"<p>In the <code>Decision threshold</code> setting: 1. Enter a numeric value. 2. Adjust to balance responsiveness and accuracy. </p> <p></p>"},{"location":"Tutorial/#combined-context-influence","title":"Combined Context Influence","text":"<p>In complex decision-making circumstances, the end result is shaped by the interaction of numerous contexts rather than by a single context in isolation. To effectively simulate the complexity in the real world, the Combined Context Influence is required. </p>"},{"location":"Tutorial/#configuring-combined-context-influence","title":"Configuring Combined Context Influence","text":"<p>In the <code>new combined context influence</code> setting. 1. Input pairs of contexts that interact with each other. 2. Assign a numerical value (influence value) to these pairs to indicate their combined effect on an intention.</p> <p></p>"},{"location":"Tutorial/#graphical-representation","title":"Graphical Representation","text":"<ul> <li>Visual Overview: </li> <li> <p>The graph provides a visual representation of how different contexts and intentions are interconnected.</p> </li> <li> <p>Nodes: </p> </li> <li> <p>Each node represents a context or intention. Context is displayed on the left side and intentions are displayed on the right side. Context nodes are linked to intentions they influence.</p> </li> <li> <p>Edges: </p> </li> <li>Edges between nodes show the relationships and their strength, based on the influence values set in the previous steps. The higher the influence, the thicker and greener the edge.</li> </ul>"},{"location":"Tutorial/#interacting-with-the-graph","title":"Interacting with the Graph","text":"<ul> <li>Expanding Contexts: </li> <li> <p>Upon clicking, a context node unfolds to reveal specific instantiations, each connected to relevant intentions.</p> </li> <li> <p>Adjusting Views: </p> </li> <li> <p>The graph can be zoomed in or out for a more detailed or broader view, respectively.</p> </li> <li> <p>Dynamic Interaction: </p> </li> <li>As you adjust influence values or apriori probabilities in the settings, these changes are reflected in the graph in real-time, offering immediate visual feedback.</li> </ul> <p></p> <p>This graphical representation is allowing for a clear and intuitive understanding of how various contexts and intentions are interrelated. It aids in verifying and adjusting configurations, ensuring that the system accurately interprets intentions based on the given context.</p>"},{"location":"Tutorial/#example-scenario","title":"Example Scenario","text":"<p>Here we describe an example scenario which can be loaded from the file <code>small_example.yml</code>. We have a very small scenario where a human can be assisted by a robot. In this scenario the human either wants the robot to pick up a tool or hand over a tool. What the robot can perceive is if the human is holding an object, the human activity and a speech command from the human.</p>"},{"location":"Tutorial/#1-context-setup","title":"1. Context Setup:","text":"<ul> <li>speech commands: The context <code>speech commands</code> has the following three instantiations: <code>pickup</code>, <code>hand over</code>, <code>other</code></li> <li>human holding object: The context Human Holding Object can either be <code>True</code> or <code>False</code></li> <li>human activity: The context <code>human activity</code> can either be <code>working</code> or <code>idle</code></li> </ul>"},{"location":"Tutorial/#2-intention-setup","title":"2. Intention Setup:","text":"<p>In this scenario we only have the intentions <code>hand over tool</code> and <code>pick up tool</code>.</p>"},{"location":"Tutorial/#3-setting-values","title":"3. Setting Values:","text":"<ul> <li>Apriori Probabilities for Context</li> <li>To set the apriori probabilities for the context instantiations, we have to ask ourselves \"How likely is it that this instantiation occurs\". If we have no knowledge about that it is a good fit to just equally distribute the probability over all instantiations.</li> <li>Influence Values for Context-Intention pairs</li> <li>For every Context-Intention pair you need to ask yourselves \"How much influence has this context instantiation on this intention\".</li> <li>Decision Threshold:</li> <li>For our scenario we set the decision threshold to 0.8. This means that for any intention to be recognized as valid, the associated probability must exceed this threshold. With 80% we assure that the system must be quite confident for the inferred intention.</li> <li>Cobined Context Influence</li> <li>Most of the cases can be covered by just setting the influence values for all Context-Intention pairs. But in some cases there is the need to give a very specific influence to the combined occurrence of two or more contexts. In this example we decided to give the case where the human is <code>working</code> while giving the <code>speech command</code> <code>pick up tool</code> a extra high influence to make sure that in this case the robot is very certain that it needs to assist the human to pick up the tool.</li> </ul>"},{"location":"Tutorial/#4-outcome","title":"4. Outcome:","text":"<p>To test the inference on your config you can use the script <code>small_example_from_yml.py</code> in an interactive Jupyter Shell. Try to change the evidence to see if your configuration describes the scenario as expected.</p> <p>This example shows how the CoBaIR can assess different contextual factors and their influence on possible intentions, thereby interpreting and acting upon human intentions in a dynamic environment.</p>"}]}